package com.spentoo.category.service;

import com.opencsv.CSVReader;
import com.spentoo.category.dto.CategoryDTO;
import com.spentoo.category.dto.CreateCategoryRequestDTO;
import com.spentoo.category.dto.RenameCategoryRequestDTO;
import com.spentoo.category.dto.UpdateCategoryRequestDTO;
import com.spentoo.category.model.Category;
import com.spentoo.category.model.CategoryType;
import com.spentoo.category.repository.CategoryRepository;
import com.spentoo.user.model.User;
import com.spentoo.user.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CategoryService {

    private final CategoryRepository categoryRepository;
    private final UserRepository userRepository;

    public CategoryService(CategoryRepository categoryRepository, UserRepository userRepository) {
        this.categoryRepository = categoryRepository;
        this.userRepository = userRepository;
    }

    @Transactional
    public CategoryDTO createCategory(CreateCategoryRequestDTO requestDTO, String userEmail) {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found."));

        String formattedCategoryName = formatCategoryName(requestDTO.getCategoryName());

        // Check for duplicate - only active categories should block creation
        Optional<Category> existingCategory = categoryRepository.findByUserAndCategoryNameIgnoreCase(user, formattedCategoryName);
        if (existingCategory.isPresent()) {
            Category existing = existingCategory.get();
            if (existing.isActive()) {
                throw new IllegalStateException("A category with this name already exists for your account.");
            } else {
                // If an inactive category exists with the same name, restore it instead of creating a duplicate
                throw new IllegalStateException("A deleted category with this name exists. Please restore it instead of creating a new one.");
            }
        }
        Category parentCategory = null;
        if (requestDTO.getParentCategoryId() != null) {
            parentCategory = categoryRepository.findById(requestDTO.getParentCategoryId())
                    .orElseThrow(() -> new IllegalStateException("Parent category not found."));
        }
        Category newCategory = new Category();
        newCategory.setCategoryName(formattedCategoryName);
        newCategory.setType(requestDTO.getType());
        newCategory.setUser(user);
        newCategory.setParentCategory(parentCategory);
        newCategory.setIcon(requestDTO.getIcon());
        newCategory.setColor(requestDTO.getColor());
        newCategory.setSortOrder(requestDTO.getSortOrder());
        newCategory.setActive(true);
        newCategory.setDefault(false);
        newCategory.setSystemGenerated(false); // New categories are not system generated by default
        Category savedCategory = categoryRepository.save(newCategory);
        return convertToDTO(savedCategory);
    }

    // This method will be used internally to create system-generated categories
    @Transactional
    public Category createSystemGeneratedCategory(User user, String categoryName, CategoryType type) {
        // Call the overloaded method with null icon and color for backward compatibility
        return createSystemGeneratedCategory(user, categoryName, type, null, null);
    }

    // Overloaded method with icon and color support
    @Transactional
    public Category createSystemGeneratedCategory(User user, String categoryName, CategoryType type, String icon, String color) {
        String formattedCategoryName = formatCategoryName(categoryName);
        Optional<Category> existing = categoryRepository.findByUserAndCategoryNameIgnoreCaseAndIsSystemGenerated(user, formattedCategoryName, true);
        if (existing.isPresent()) {
            return existing.get(); // Return existing if already present for this user
        }

        Category newCategory = new Category();
        newCategory.setCategoryName(formattedCategoryName);
        newCategory.setType(type);
        newCategory.setUser(user); // Link to the user
        newCategory.setIcon(icon);
        newCategory.setColor(color);
        newCategory.setActive(true);
        newCategory.setDefault(true); // System-generated categories are considered defaults
        newCategory.setSystemGenerated(true); // Mark as system generated
        return categoryRepository.save(newCategory);
    }


    @Transactional(readOnly = true)
    public List<CategoryDTO> getAllCategories(String userEmail) {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found.")); // Corrected
        // Return all categories (active and inactive) so users can restore deleted ones
        return categoryRepository.findAllByUser(user)
                .stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<CategoryDTO> getSubcategoriesByParentCategory(Integer parentCategoryId, String userEmail) {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found."));
        
        Category parentCategory = categoryRepository.findById(parentCategoryId)
                .filter(cat -> cat.getUser().getUserId().equals(user.getUserId()))
                .orElseThrow(() -> new IllegalStateException("Parent category not found or access denied."));
        
        // Get only active, budgetable subcategories of the parent category
        return categoryRepository.findAllByUserAndParentCategoryAndIsActiveTrue(user, parentCategory)
                .stream()
                .filter(category -> category.isBudgetable()) // Filter budgetable categories
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public CategoryDTO getCategoryById(Integer categoryId, String userEmail) {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found.")); // Corrected
        return categoryRepository.findById(categoryId)
                .filter(category -> category.getUser().getUserId().equals(user.getUserId()))
                .map(this::convertToDTO)
                .orElseThrow(() -> new IllegalStateException("Category not found or access denied."));
    }

    @Transactional
    public CategoryDTO updateCategory(Integer categoryId, UpdateCategoryRequestDTO requestDTO, String userEmail) {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found.")); // Corrected
        Category category = categoryRepository.findById(categoryId)
                .filter(cat -> cat.getUser().getUserId().equals(user.getUserId()))
                .orElseThrow(() -> new IllegalStateException("Category not found or access denied."));

        if (category.isSystemGenerated()) {
            throw new IllegalStateException("System-generated categories cannot be modified.");
        }
        if (category.isDefault()) {
            throw new IllegalStateException("Default categories cannot be modified.");
        }
        if (requestDTO.getCategoryName() != null && !requestDTO.getCategoryName().equals(category.getCategoryName())) {
            String formattedCategoryName = formatCategoryName(requestDTO.getCategoryName());

            categoryRepository.findByUserAndCategoryNameIgnoreCase(user, formattedCategoryName).ifPresent(existing -> {
                throw new IllegalStateException("A category with this name already exists for your account.");
            });

            category.setCategoryName(formattedCategoryName);
        }
        if (requestDTO.getType() != null) {
            category.setType(requestDTO.getType());
        }
        if (requestDTO.getIcon() != null) {
            category.setIcon(requestDTO.getIcon());
        }
        if (requestDTO.getColor() != null) {
            category.setColor(requestDTO.getColor());
        }
        if (requestDTO.getSortOrder() != null) {
            category.setSortOrder(requestDTO.getSortOrder());
        }
        if (requestDTO.getParentCategoryId() != null) {
            Category parentCategory = categoryRepository.findById(requestDTO.getParentCategoryId())
                    .orElseThrow(() -> new IllegalStateException("Parent category not found."));
            category.setParentCategory(parentCategory);
        }
        Category updatedCategory = categoryRepository.save(category);
        return convertToDTO(updatedCategory);
    }

    @Transactional
    public void deleteCategory(Integer categoryId, String userEmail) {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found.")); // Corrected
        Category category = categoryRepository.findById(categoryId)
                .filter(cat -> cat.getUser().getUserId().equals(user.getUserId()))
                .orElseThrow(() -> new IllegalStateException("Category not found or access denied."));

        if (category.isSystemGenerated()) {
            throw new IllegalStateException("System-generated categories cannot be deleted.");
        }
        if (category.isDefault()) {
            throw new IllegalStateException("Default categories cannot be deleted.");
        }
        boolean hasActiveSubCategories = category.getSubCategories().stream().anyMatch(Category::isActive);
        if (hasActiveSubCategories) {
            throw new IllegalStateException("Cannot delete a category with active sub-categories.");
        }
        category.setActive(false);
        categoryRepository.save(category);
    }

    @Transactional
    public CategoryDTO restoreCategory(Integer categoryId, String userEmail) {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found.")); // Corrected
        Category category = categoryRepository.findById(categoryId)
                .filter(cat -> cat.getUser().getUserId().equals(user.getUserId()))
                .orElseThrow(() -> new IllegalStateException("Category not found or access denied."));

        if (category.isSystemGenerated()) {
            throw new IllegalStateException("System-generated categories cannot be restored.");
        }
        if (category.isActive()) {
            throw new IllegalStateException("Category is already active.");
        }
        String formattedCategoryName = formatCategoryName(category.getCategoryName());

        categoryRepository.findByUserAndCategoryNameIgnoreCaseAndIsActiveTrue(user, formattedCategoryName).ifPresent(existing -> {
            if (!existing.getCategoryId().equals(categoryId)) {
                throw new IllegalStateException("An active category with this name already exists for your account.");
            }
        });
        if (category.getParentCategory() != null && !category.getParentCategory().isActive()) {
            throw new IllegalStateException("Cannot restore a category whose parent is inactive.");
        }
        category.setActive(true);
        Category restoredCategory = categoryRepository.save(category);
        return convertToDTO(restoredCategory);
    }

    @Transactional
    public CategoryDTO renameCategory(Integer categoryId, RenameCategoryRequestDTO requestDTO, String userEmail) {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found.")); // Corrected
        Category category = categoryRepository.findById(categoryId)
                .filter(cat -> cat.getUser().getUserId().equals(user.getUserId()))
                .orElseThrow(() -> new IllegalStateException("Category not found or access denied."));

        if (category.isSystemGenerated()) {
            throw new IllegalStateException("System-generated categories cannot be renamed.");
        }
        if (category.isDefault()) {
            throw new IllegalStateException("Default categories cannot be renamed.");
        }
        if (requestDTO.getNewName() == null || requestDTO.getNewName().trim().isEmpty()) {
            throw new IllegalStateException("New name cannot be empty.");
        }
        String formattedNewName = formatCategoryName(requestDTO.getNewName());
        if (formattedNewName.equals(category.getCategoryName())) {
            return convertToDTO(category); // No change needed
        }
        categoryRepository.findByUserAndCategoryNameIgnoreCaseAndIsActiveTrue(user, formattedNewName).ifPresent(existing -> {
            if (!existing.getCategoryId().equals(categoryId)) {
                throw new IllegalStateException("An active category with this name already exists for your account.");
            }
        });
        category.setCategoryName(formattedNewName);
        Category renamedCategory = categoryRepository.save(category);
        return convertToDTO(renamedCategory);
    }

    @Transactional
    public void importCategories(MultipartFile file, String userEmail) throws Exception {
        User user = userRepository.findByEmailIgnoreCase(userEmail)
                .orElseThrow(() -> new IllegalStateException("User not found.")); // Corrected
        List<Category> categoriesToSave = new ArrayList<>();
        try (Reader reader = new InputStreamReader(file.getInputStream());
             CSVReader csvReader = new CSVReader(reader)) {
            csvReader.skip(1); // Skip header row
            String[] line;
            while ((line = csvReader.readNext()) != null) {
                String categoryName = line[1];
                String typeStr = line[2];
                if (categoryName == null || categoryName.trim().isEmpty() || typeStr == null || typeStr.trim().isEmpty()) {
                    throw new IllegalStateException("Category name and type are required.");
                }
                String formattedCategoryName = formatCategoryName(categoryName);

                if (categoryRepository.findByUserAndCategoryNameIgnoreCase(user, formattedCategoryName).isPresent()) {
                    continue; // Skip if an active category with this name already exists
                }
                Category newCategory = new Category();
                newCategory.setCategoryName(formattedCategoryName);
                newCategory.setType(CategoryType.valueOf(typeStr.toUpperCase()));
                newCategory.setUser(user);
                newCategory.setIcon(line[3]);
                newCategory.setColor(line[4]);
                if (line[5] != null && !line[5].isEmpty()) {
                    newCategory.setSortOrder(Integer.parseInt(line[5]));
                }
                if (line[6] != null && !line[6].isEmpty()) {
                    Category parent = categoryRepository.findById(Integer.parseInt(line[6])).orElse(null);
                    newCategory.setParentCategory(parent);
                }
                newCategory.setActive(true);
                newCategory.setDefault(false);
                newCategory.setSystemGenerated(false); // Imported categories are not system generated
                categoriesToSave.add(newCategory);
            }
        }
        if (!categoriesToSave.isEmpty()) {
            categoryRepository.saveAll(categoriesToSave);
        }
    }

    public CategoryDTO convertToDTO(Category category) { // Changed to public
        if (category == null) {
            return null;
        }
        CategoryDTO dto = new CategoryDTO();
        dto.setCategoryId(category.getCategoryId());
        dto.setCategoryName(category.getCategoryName());
        dto.setType(category.getType());
        dto.setIcon(category.getIcon());
        dto.setColor(category.getColor());
        dto.setSortOrder(category.getSortOrder());
        dto.setDefault(category.isDefault());
        dto.setActive(category.isActive());
        dto.setCreatedAt(category.getCreatedAt());
        dto.setUpdatedAt(category.getUpdatedAt());
        if (category.getParentCategory() != null) {
            dto.setParentCategoryId(category.getParentCategory().getCategoryId());
        }
        if (category.getSubCategories() != null && !category.getSubCategories().isEmpty()) {
            dto.setSubCategories(
                category.getSubCategories().stream()
                        .map(this::convertToDTO)
                        .collect(Collectors.toSet())
            );
        }
        return dto;
    }

    private String formatCategoryName(String name) {
        if (name == null || name.trim().isEmpty()) {
            return name;
        }
        String trimmedName = name.trim();
        if (trimmedName.length() == 1) {
            return trimmedName.toUpperCase();
        }
        return trimmedName.substring(0, 1).toUpperCase() + trimmedName.substring(1).toLowerCase();
    }
}
